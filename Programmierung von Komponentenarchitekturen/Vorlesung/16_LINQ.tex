\slideScale{.47}
\section{Nutzen von Link}
\slides{Vorlesung/16_LINQ_Studentenversion}{2}
\slides{Vorlesung/16_LINQ_Studentenversion}{3}
\slides{Vorlesung/16_LINQ_Studentenversion}{4}

\section{Beispielszenario}
\slides{Vorlesung/16_LINQ_Studentenversion}{5}
\slides{Vorlesung/16_LINQ_Studentenversion}{6}
\subsection{Ohne LINQ}
\slides{Vorlesung/16_LINQ_Studentenversion}{7}
\subsection{Mit LINQ}
\slides{Vorlesung/16_LINQ_Studentenversion}{8}

\section{LINQ Abfrage}
\slides{Vorlesung/16_LINQ_Studentenversion}{9}

\subsection{Syntax}
\slides{Vorlesung/16_LINQ_Studentenversion}{10}
\subsection{Gegenüberstellung}
\slides{Vorlesung/16_LINQ_Studentenversion}{11}
\slides{Vorlesung/16_LINQ_Studentenversion}{12}
\subsection{Schlüsselwärter und (Standard-)Abfrageoperatoren}
\slides{Vorlesung/16_LINQ_Studentenversion}{13}
\subsection{Struktur}
\slides{Vorlesung/16_LINQ_Studentenversion}{14}
\subsection{from und select -- Datenquelle und Auswahl}
\slides{Vorlesung/16_LINQ_Studentenversion}{15}
\slides{Vorlesung/16_LINQ_Studentenversion}{16}
Selektor: \lstinline`person => person` (Delegate) entspricht hier \lstinline`SELECT *`

\subsubsection*{Beispiel}
\slides{Vorlesung/16_LINQ_Studentenversion}{17}
\begin{itemize}
\item Wenn im Vornherein die Datenquelle bekannt ist, kann IntelliSense entsprechend der Quelle Vorschläge machen.
\item Ergebnis ist vom Typ \lstinline`IEnumerable<Person>`
\end{itemize}

\subsection{Selektor}
\lecdate{16.06.2017}
\slides{Vorlesung/16_LINQ_Studentenversion}{18}

\subsection{Unterabfragen}
\slides{Vorlesung/16_LINQ_Studentenversion}{19}

\subsubsection*{Beispiel}
\slides{Vorlesung/16_LINQ_Studentenversion}{20}
Antwort Kinder:\\
8 Elemente:
\begin{itemize}
\item Hans hat 2 Kinder, 
\item Ruth hat 2 Kinder,
\item Klaus hat 1 Kind,
\item Petra hat 1 Kind,
\item Günther hat 1 Kind,
\item Manuela hat 1 Kind
\end{itemize}
(die entstandenen Duplikate könnten mit \lstinline`DISTINCT` entfernt werden.\bigskip\\
Antwort Enkel:\\
8 Elemente
\begin{itemize}
\item Klaus, Petra, Günther und Manuela haben je zwei Enkelkinder 
\end{itemize}

\subsection{Select vs SelectMany}
\slides{Vorlesung/16_LINQ_Studentenversion}{21}
\slides{Vorlesung/16_LINQ_Studentenversion}{22}
\slides{Vorlesung/16_LINQ_Studentenversion}{23}

\subsection{Where}
\slides{Vorlesung/16_LINQ_Studentenversion}{24}
\slides{Vorlesung/16_LINQ_Studentenversion}{25}

\subsection{Ausführen der Abfrage}
\slides{Vorlesung/16_LINQ_Studentenversion}{26}
\slides{Vorlesung/16_LINQ_Studentenversion}{27}
\subsubsection*{Beispiel 1}
\slides{Vorlesung/16_LINQ_Studentenversion}{28}
\subsubsection*{Beispiel 2}
\slides{Vorlesung/16_LINQ_Studentenversion}{29}
$\to $ Funktioniert SELECT immer oder braucht jede Datenquelle ein eigenes SELECT?\\
NEIN!\\
Abfragesyntax ist nicht fest mit den entsprechenden Standardabfrageoperatoren verdrahtet.\\
Es wird eine Zwischenschicht benötigt, die zwischen LINQ abfrage und Datenquelle liegt ($\to$ LINQ-Provider)

\subsection{GroupBy}
\slides{Vorlesung/16_LINQ_Studentenversion}{32}
\slides{Vorlesung/16_LINQ_Studentenversion}{33}
\subsubsection*{Beispiel}
\slides{Vorlesung/16_LINQ_Studentenversion}{34}
\subsubsection{Composite-Keys}
\slides{Vorlesung/16_LINQ_Studentenversion}{35}

\section{LINQ-Provider/Implementierungen/Flavors}
\slides{Vorlesung/16_LINQ_Studentenversion}{30}
\slides{Vorlesung/16_LINQ_Studentenversion}{31}

\section{Weiteres}
\subsection{Abfrageoperatoren}
\slides{Vorlesung/16_LINQ_Studentenversion}{38}
\subsection{Anwendungsbeispiel}
\slides{Vorlesung/16_LINQ_Studentenversion}{39}
