% LaTeX master Datei(en) zusammengestellt von Falk-Jonatan Strube zur Nutzung an der Hochschule für Technik und Wirtschaft Dresden: https://github.com/genericFJS/htw\documentclass{scrreprt}
\documentclass{scrreprt}
\gdef\pathtomaster{../_LaTeX_master}
\input{\pathtomaster/htwcd_content.sty}
\input{\pathtomaster/fjs_packages-macros.sty}

\faculty{Fakultät Informatik/Mathematik}
\chair{Lehrstuhl für Softwaretechnologie}
\subject{lecture}
\title{Software Engineering 2}
\author{Falk-Jonatan Strube}
\professor{Prof. Dr. Anna Sabine Hauptmann}

\slidePath{Vorlesung/VO}
\begin{document}
\maketitle
\tableofcontents
\part{Vorlesung}
\chapter*{Einführung}
\section*{Belegarbeit}
\slides{01}{3}
Im Protokoll (bei Bedarf) nicht vergessen:
\begin{itemize}
\item Teilnehmende (entschuldigt/unentschuldigt)
\item Festsetzungsprotokoll (wer macht was bis wann?)
\end{itemize}
\chapter{Entwurf, Architektur, Risiken}
\lecdate{21.03.2017}
\section{Rückblick}
\slides{01}{7}
\slides{01}{8}
\section{Prozess und Produkt}
\slides{01}{10}
\section{Struktur}
\slides{01}{11}
\section{Grob- und Feinentwurf}
\slides{01}{12}
\section{System vs Software-System}
\slides{01}{13}
\slides{01}{21}
\section{Komplexität}
\slides{01}{14}
\section{Risiko beim Software-Entwurf}
\slides{01}{18}
\section{Fragen bei der Softwarentwicklung}
\slides{01}{22}
\section{Zusammenfassung}
\slides{01}{23}

\chapter{Module, Schnittstellen, Entwurf, Architektur}
\lecdate{28.03.2017}
\slides{02}{3}
\section{Komponenten und Module}
\slides{02}{4}
\slides{02}{5}

\section{Schnittstellen}
\slides{02}{8}
\slides{02}{9}

\section{Entwurf: Prinzipien und Perspektiven}
\slides{02}{10}
\slides{02}{17}

\section{Architektur}
\slides{02}{11}
\subsection{Drei-Schichten-Architektur versus physische Verteilung}
\slides{02}{12}
\slides{02}{13}
$\to$ Die Drei-Schichten-Architektur sagt nichts über die physische Verteilung der Schichten aus.
\subsection{Model-View-Control Paradigma}
\slides{02}{14}
%\slides{02}{15}
\subsubsection*{Entkopplung von View und Model}
\slides{02}{16}

\chapter{Entwurfsprinzipien}
\lecdate{11.04.2017/1}
\section{Systemstruktur}
\slides{03}{2}
\section{Struktur im Inneren des Systems}
\slides{03}{3}
\begin{itemize}
\item Kopplung: Einfluss von „Außen“
\item Kohäsion: Einfluss von „Innen“ (untereinander)
\end{itemize}
\slides{03}{5}
\section{Unterstützung von loser Kopplung / innere Bindung}
\slides{03}{6}
Vergleich: Aufteilung in Klassen.
\slides{03}{10}
\section{Kopplung und Kohäsion}
\subsection{Kopplung}
\slides{03}{8}
\subsection{Kohäsion}
\slides{03}{9}
\section{Beschreibung einer Programmierschnittstelle}
(bspw. Klassenebene)\\
Jede öffentliche Operation/Funktion braucht:
\begin{itemize}
\item Signatur: Syntax -- \lstinline$ ____ name (...)$
\item Wesen: Semantik -- Was die Operation tut.
\item Vorbedingungen
\item Nachbedingungen
\item Invariante (nicht veränderlich)
\item Protokoll (synchron/asynchron)
\item Kosten (Zeit, Rechenleistung, Dienste[$\to$Geld], …)
\end{itemize}
$\to$ Anforderungen (funktional [$\to$ Signatur / Wesen], Qualitätsanforderungen [$\to$ Vor-/Nachbed. / Invariant / Protokoll], Rahmenbedingungen [$\to$ Kosten])
\section{Langlebige Struktur im inneren System}
\slides{03}{11}
$\to$ Open/Closed Prinzip
\section{Grundlegende Entwurfsprinzipien}
\slides{03}{12}

\chapter{Muster}
\lecdate{11.04.2017/2}
\slides{04}{9}
\slides{04}{5}
\slides{04}{6}
Kategorien von Mustern:
\begin{itemize}
\item Architektur-Unabhängig:
\begin{itemize}
\item Architektur-Muster (im Grobentwurf)
\item Entwurfs-Muster (im Feinentwurf, näher an der Implementierung)
\end{itemize}
\item Für bestimmte Implementierungen (abhängig von der Sprache):
\begin{itemize}
\item Idiom
\end{itemize}
\end{itemize}

\section{Grundlegende Architekturen}
\subsection{Schichten / Layer}
\slides{04}{14}

\subsection{Datenfluss und Filter / Pipes-and-Filters}
Daten fließen durch Filter-Komponenten (Beispiele: Compiler, Converter, …).

\subsection{Depot-Architektur}
In einem Depot sind Informationen, in Anwendungen/Teilsystemen werden diese dargestellt oder verarbeitet (Vergleich: objectiF/case4.0 … Klassendiagramm und Sequenzdiagramm greifen auf Objekte zurück [beim Löschen ist bspw. dann die Frage: Soll die Representation oder das Objekt im Depot gelöscht werden]).

\subsection{Client-Server-Architektur}
Weiterentwicklung der Depot-Architektur: Das Depot verarbeitet nun auch Informationen (bekommt Funktionalität).

\subsection{Peer-to-Peer-Architektur}
Spezielle Client-Server-Architektur, wo der Client und Server eine Komponente sind.

\subsection{Proxy-Pattern (Vermittler/Broker)}
\lecdate{18.04.2017}
\paragraph{Kontext, Problem} Netzwerk von Clients und Servern, die Informationen austauschen sollen.
\paragraph{Lösungsstrategie} Eine spezielle Komponente übernimmt die \emph{Vermittlung} zwischen Clients und Server(n)
\paragraph{Konsequenzen}
\begin{itemize}
\item Effizienz sinkt $\downarrow$
\item Fehleranfälligkeit steigt $\uparrow$\\
$\Rightarrow$Fehlertoleranzmaßnahmen (redundant, Prüf-Funktionalitäten)
\item Kommunikationsaufwand steigt $\uparrow$
\end{itemize}
\begin{center}
\begin{tikzpicture}
\draw  (4.0,-1.5) rectangle node [] {Server}(6.5,-2.5) ;
\draw  (4,0) rectangle node [] {Server Proxy}(6.5,-1) ;
\draw  (0.5,0) rectangle node [] {Broker}(3,-1) ;
\draw  (-3.0,-1.5) rectangle node [] {Client}(-.5,-2.5) ;
\draw  (-3,0) rectangle node [] {Client Proxy}(-.5,-1);

\draw [-latex](-1.5,-1.5) -- (-1.5,-1);
\draw [latex-latex](-0.5,-0.5) -- (0.5,-0.5);

\draw [latex-latex](3,-0.5) -- (4,-0.5);

\draw [latex-] (5.5,-1) -- (5.5,-1.5);
\end{tikzpicture}
\end{center}

\subsection{Säulenarchitektur}
Client (Benutzerschnittstelle) $\longleftrightarrow$ Anwendungslogik $\longleftrightarrow$ Server (Datenbank-Server)

\subsubsection{3-Säulen-Architektur}
Client $\longleftrightarrow$ Applikationsserver (Anwendungsserver) $\longleftrightarrow$ DB-Server

\subsubsection{4-Säulen-Architektur}
Client $\longleftrightarrow$ Formularerstellung $\longleftrightarrow$ Applikationsserver (Anwendungsserver) $\longleftrightarrow$ DB-Server

\begin{center}
\begin{tikzpicture}[scale=.9]

\draw  (-2.5,0) rectangle (-1.5,-3);
\draw  [htworange](-1.5,0) rectangle (-0.5,-1.5);
\node at (-2,-3.5) [align=center]{Client\\Benutzerschnittstelle};
\draw  [htworange](2.5,-3) node (v1) {} rectangle (1.5,-1.5);
\draw  (v1) rectangle (3.5,0);
\node at (2.5,-3.8) [align=center]{Server\\Datenbank-Server\\(zentrale Datenhaltung)};
\draw [latex-](-1,-2.5) -- (-0.5,-2.5);
\draw [-latex](0.5,-2.5) -- (1,-2.5);
\node at (0,-2.5) [align=center]{Anwendungs-\\logik};

\node [scale=2.5]at (5,-1.5) {$\Rightarrow$};
\draw  (6,0) rectangle (7,-3);
\draw  [red](8.5,0) rectangle (9.5,-3);
\draw  (11,0) rectangle (12,-3);
\draw [latex-latex](7,-1) -- (8.5,-1);
\draw [latex-latex](9.5,-1) -- (11,-1);
\draw [-latex](7,-2) -- (8.5,-2);
\draw [-latex](9.5,-2) -- (11,-2);
\node at (6.5,0) [align=center, above]{Client};
\node at (9,-3) [align=center, below]{Applikationsserver\\(Anwendungsserver)};
\node at (11.5,0)[align=center, above] {DB-Server};
\end{tikzpicture}
\end{center}
\subsection{Reflection}
\paragraph{Kontext, Problem} \emph{reflexives System}, d.h. dynamische Veränderung von Struktur + Verhalten
\paragraph{Lösungsstrategie}
\begin{itemize}
\item Metaebene $\rightarrow$ Informationen über spezielle Systemeigenschaften
\item Basisebene $\rightarrow$ Anwendungslogik
\end{itemize}
$\rightsquigarrow$ Veränderung in der Metaebene beeinflussen die Basisebene

\subsection{Quasar}
\lecdate{25.04.2017}
Referenzarchitektur\\
Wurde entwickelt bei der Firma „sd\&m“ (1982-2001, seit 2001 bei „Capgemini“).
\paragraph{Ziel}
\begin{itemize}
\item Trennung von Zuständigkeiten realisieren
\item Programmierung gegen Schnittstellen realisieren
\item Denken in Komponenten fördern
\end{itemize}
\paragraph{Trennung von Zuständigkeiten}
Ansatz bei Quasar: SW-Komponenten klassifizieren durch Definition von \emph{SW-Kategorien}
\subparagraph{SW-Kategorien} $\to $ Trennung von \emph{Anwendung} und \emph{Technik}
\begin{itemize}
\item Kategorie A-Software\\
von fachlicher Anwendung bestimmt
\item Kategorie T-Software\\
technische Komponenten, von mindestens einer API bestimmt (DB-anschluss, Technologie der Oberflächenprogrammierung, …)
\end{itemize}
weitere:
\begin{itemize}
\item Kategorie AT-Software (möglichst vermeiden!)\\
Mischung aus A- und T-Komponenten
\item Kategorie R-Softwaree\\
reserviert für Bausteine, die als Transformator zwischen A- und T-Software  liegen
\end{itemize}
Einfache Darstellung:
\begin{center}
\begin{tikzpicture}[scale=.9]
\draw [red] (-3,1.5) rectangle node[align=center]{Anwendungskern\\ A-Software} (2,-0.5);
\draw [blue] (-3,-0.5) rectangle node[align=center]{R-Software} (2,-1.5);
\draw [orange] (-3,-2.5) rectangle node[align=center]{Persistenz-\\framework\\T-Software} (2,-4.5);
\draw  (-0.5,-6) node[]{DB} ellipse (1 and .5);
\draw (-0.5,-5.5) -- (-0.5,-4.5);
\draw (-0.5,-2.5) -- (-0.5,-1.5);
\draw (-2,1.5) -- (-2,2.5) node[rotate=90]{$\circ)$};
\draw (-1,1.5) -- (-1,2.5) node{$\circ$};
\draw (0.5,1.5) -- (0.5,2.5) node{$\circ$};
\node at (-0.5,-2)  [rotate=90]{$\circ)$};
\draw (-2,3.5) -- (-2,2.5);
\draw  (-3,4.5) rectangle node{UI1} (-1,3.5);
\draw [green] (-3.5,5) rectangle (2.5,-5);
\draw (-3,1) -- (-5,1) node{)};
\draw (-3,0) -- (-5,0) node{)};
\node [left, align=center] at (-8,0.5) {Nachbar-\\systeme};
\node [right] at (-1,4) {…};
\draw (-8,1.5) -- (-7,1.5) node{$\circ$};
\draw (-8,-0.5) -- (-7,-0.5)node{$\circ$};
\node at (-6,0.5) {Adapter};
\draw [dashed, green] (-6.5,2.5) rectangle (-3.5,-1.5);
\draw (2,0.5) -- (5,0.5) -- (5,1.5) node[above]{Authorisierung};
\draw (2,0) -- (5,0) -- (5,-1) node[below]{Regelinterpreter};
\node at (3.5,0.5) {$(\circ$};
\node at (3.5,0) {$(\circ$};
\end{tikzpicture}
\end{center}
Detaillierte Darstellung:
\slides{06Quasar}{1}

\chapter{Entwurfsmuster}
\lecdate{02.05.2017}
\section{Objektorientierte Programmierung}
\begin{itemize}
\item Instanz (in der Realität) einer abstrakten Bauanleitung
\item Kapselung
\item Vererbung
\item Schnittstelle wird benutzt ($\to$ Kapselung)
\end{itemize}
$\to$ Zusammenführung von Daten und Methoden.
\slides{06}{3}
\subsection{Objekt}
\slides{06}{5}
\slides{06}{6}
\slides{06}{7}
\subsection{Vererbung}
\slides{06}{8}
\slides{06}{9}
\subsubsection{Substitutionsprinzip}
\slides{06}{10}
\subsubsection{Chancen und Gefahren der Vererbung}
\slides{06}{11}

\section{Entwurfsmuster}
\slides{06}{12}
\slides{06}{14}
\slides{06}{15}
\subsection{Erzeugermuster}
\slides{06}{16}


\part{Praktikum}
\setcounter{chapter}{0}
\input{HTW_Software_Engineering2_Skript_prakt}
\end{document}