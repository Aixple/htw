\begin{itemize}
\item Oft müssen ähnliche Operationen / Funktionalitäten für unterschiedliche Datentypen bereitgestellt werden
\item Um nicht gleichen Code mehrfach zu schreiben nutzt man Platzhalter (template) für Datentypen
\item Beispiel: List<T>
\end{itemize}

\section{Generische Klasse definieren}

\begin{lstlisting}[language={[Sharp]C}]
class GenericClass<T> {
	T myVariable;
	public GenericClass(T myVar){
		myVariable = myVar;	
	}
	public T MyVariable{
		get {
			return myVariable;		
		}
	}
}
\end{lstlisting}

\section{Generische Klasse benutzen}

\begin{lstlisting}[language={[Sharp]C}]
GenericClass<int> a = new GenericClass<int>(5);
\end{lstlisting}

\begin{center}
\includegraphics{Vorlesung/a7Generik-img001.png}
\end{center}

Ähnlich für: 
\begin{itemize}
\item struct 
\item interfaces
\item delegates
\end{itemize}
~

\section{Generische Methoden}
Generik funktioniert genauso für Methoden
\begin{lstlisting}[language={[Sharp]C}]
class MyClass {
	public static void Swap<T>(ref T l, ref T r) { 
	// auch möglich mit mehreren Generiks:
	// public static void Swap<T1, T2>(ref T1 l, ref T2 r) { 
		T temp = r;
		r = l;
		l = temp;   
	}
}

int a = 3;
int b = 4;
MyClass.Swap(ref a, ref b);
\end{lstlisting}

\section{Template Constraints}
Constraints = Vorgaben an die Templates

\subsection{Interface Constraint}

\begin{lstlisting}[language={[Sharp]C}]
public static void Swap<T>(ref T l, ref T r) where T : IComparable{
	if (l.CompareTo(r) < 0)  {
		T temp = r;
		r = l;
		l = temp;
	}
}
\end{lstlisting}

\subsection{Klassen Constraint}
\begin{lstlisting}[language={[Sharp]C}]
class MyGenericClass<T> where T : IComparable{

}
\end{lstlisting}
\subsection{Vererbungs Constraints}

\begin{lstlisting}[language={[Sharp]C}]
class MyGenericClass<T> where T : Random

class MyGenericClass<T, V> where T : List<V>

class MyGenericClass<T, V> where T : List<V> where V : Random
\end{lstlisting}

\subsection{Instanzierbarkeits Constraint}
\begin{lstlisting}[language={[Sharp]C}]
T CreateNew<T>() where T : new() {
	return new T(); // geht nur wegen " : new()", sonst: Compilerfehler
}
\end{lstlisting}