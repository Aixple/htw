Viele Probleme der KI lassen sich auf eine systematische Suche in einem Wurzelbaum reduzieren. \\
Problem: Riesige Anzahl von Knoten in typischen Suchbäumen. 
\cparagraph{Beispiel} Schachspiel, ca. $30$ Möglichkeiten pro Halbzug (Zug einer Farbe). Bei $50$ Halbzügen enthält der Suchbaum:
$$\sum_{d=0}^{50} 30^d = \frac{30^{51}-1}{30-1} \approx 7,4 \cdot 10^{73}\unit{Knoten}$$
Bei $10\, 000$ Computern, die $10^9 \unit{Knoten/s}$ erzeugen und durchsuchen können, würde das durchsuchen so lange dauern:
$$ \frac{7,4 \cdot 10^{73}}{10\,000 \cdot 10^9}\unit{s}=2,3 \cdot 10^{53} \unit{Jahre}$$

\section{Uninformierte Suche}
Bereits bekannt: Breiten- und Tiefensuche. Zur Implementierung in Prolog benötigen wir:
\begin{itemize}
\item \lstinline`findall(X, P, L)`: Sucht alle \lstinline`X`, für die \lstinline`P` wahr ist und erzeugt daras die Liste \lstinline`L`.
\item \lstinline`not(P)`: Ist wahr genau dann, wenn Prolog \lstinline`P` nicht beweisen kann („Negation by failure“).
\end{itemize}
\subsection{Breitensuche}
\begin{lstlisting}[language=Prolog]
% Adjazenzrelation des ungerichteten Graphen (nicht effizient)
adj(X,Y) :- adj0(X,Y); adj0(Y,X).
adj0(X,Y) :- member((X,Y), [(1,2), (2,4), (2,5), (3,4), (3,6), (4,5)]).

goal(6).

% Breitensuche
bfs([H|T], Discovered) :-
	goal(H);
	findall(Node, (adj(H, Node), not(member(Node, Discovered))), NewNeighbors),
	append(T, NewNeighbors, Queue),
	append(Discovered, NewNeighbors, Dc),
	write('Queue: '), writeln(Queue), % zur Illustration
	bfs(Queue, Dc).
\end{lstlisting}

Starten der Breitensuche beim Knoten $1$:
\begin{lstlisting}[language=Prolog]
?- bfs([1], [1]).
Queue: [2]
Queue: [4,5]
Queue: [5,3]
Queue: [3]
Queue: [6]
true .
\end{lstlisting}
\subsection{Problem der Breiten- und Tiefensuche} 
Wenn alle bereits besuchten Knoten gespeichert werden: Exponentielle Laufzeit und exponentieller Speicherplatzbedarf (für die Discoverd-Liste) in der Tiefe des Baumes.
\subsection{Tiefensuche}
Einfach: aus \lstinline`append(T, NewNeighbors, Queue)` wird \lstinline`append(NewNeighbors, T, Queue`.\\
Ohne expliziten Stack, Knoten auf aktuellen Pfad werden gespeichert (nicht alle Knoten wie bei Discovered $\to$ vermeidet exponentiellen Speicherplatzbedarf -- funktioniert, da der zu durchsuchende Graph in der Regel ein Baum ist [Knoten könnten nur durch Schleifen doppelt besucht werden]):
\begin{lstlisting}[language=Prolog]
% Adjazenzrelation des ungerichteten Graphen (nicht effizient)
adj(X,Y) :- adj0(X,Y); adj0(Y,X).
adj0(X,Y) :- member((X,Y), [(1,2), (2,4), (2,5), (3,4), (3,6), (4,5)]).

goal(6).

dfs3(Node, Path) :-
	goal(Node);
	adj(Node, NewNeighbor), not(member(NewNeighbor,Path)),
	write('Knoten: '), writeln(NewNeighbor), % zur Illustration
	dfs3(NewNeighbor, [NewNeighbor|Path]).

% Wie dfs3, gefundener ReturnPath wird zurückgegeben
dfs4(Node, Path, ReturnPath) :-
	goal(Node), reverse(Path, ReturnPath);
	adj(Node,NewNeighbor), not(member(NewNeighbor,Path)),
	dfs4(NewNeighbor, [NewNeighbor|Path], ReturnPath).
\end{lstlisting}




